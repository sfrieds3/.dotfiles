# set prompt
autoload -U promptinit && promptinit
# '#1c1c1c' 234: Grey11
# '#af5f5f' 131: IndianRed
# '#5f875f' 65: DarkSeaGreen4
# '#87875f' 101: Wheat4
# '#5f87af' 67: SteelBlue
# '#5f5f87' 60: MediumPurple4
# '#5f8787' 66: PaleTurquoise4
# '#6c6c6c' 242: Grey42
# '#444444' 238: Grey27
# '#ff8700' 208: DarkOrange
# '#87af87' 108: DarkSeaGreen
# '#ffffaf' 229: Wheat1
# '#87afd7' 110: LightSkyBlue3
# '#8787af' 103: LightSlateGrey
# '#5fafaf' 73: CadetBlue
# '#ffffff' 15: white

# a lot of this from https://github.com/wincent/wincent/blob/main/aspects/dotfiles/files/.zshrc
# and https://github.com/akinsho/dotfiles/blob/main/.config/zsh/.zshrc
# # http://zsh.sourceforge.net/Doc/Release/User-Contributions.html
autoload -Uz vcs_info
zstyle ':vcs_info:*' enable git
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:*' stagedstr "%F{108} %f"  # nf-fa-check (default 'S')
zstyle ':vcs_info:*' unstagedstr "%F{131} %f"  # nf-fa-close (default 'U')
zstyle ':vcs_info:*' use-simple true
zstyle ':vcs_info:git+set-message:*' hooks git-untracked git-stashed git-compare git-remotebranch
zstyle ':vcs_info:git*:*' formats '%F{131}%F{208}λ:%F{66}(%b)%m%c%u%F{131}%f '  # default ' (%s)-[%b]%c%u-'
zstyle ':vcs_info:git*:*' actionformats '%F{131}(%F208}λ:%F{66}(%b|%a)%m%c%u%F{131}%f '  # default ' (%s)-[%b|%a]%...c%u-'

function +vi-git-untracked() {
  emulate -L zsh
  if [[ -n $(git ls-files --directory --no-empty-directory --exclude-standard --others 2> /dev/null) ]]; then
    hook_com[unstaged]+="%F{131} %f"  # nf-fa-question
  fi
}

function +vi-git-stashed() {
  emulate -L zsh
  if [[ -n $(git rev-list --walk-reflogs --count refs/stash 2> /dev/null) ]]; then
    hook_com[unstaged]+="%F{66} %f"  # nf-fa-inbox
  fi
}

# git: Show +N/-N when your local branch is ahead-of or behind remote HEAD.
# Make sure you have added misc to your 'formats':  %m
# source: https://github.com/zsh-users/zsh/blob/545c42cdac25b73134a9577e3c0efa36d76b4091/Misc/vcs_info-examples#L180
function +vi-git-compare() {
  local ahead behind
  local -a gitstatus

  # Exit early in case the worktree is on a detached HEAD
  git rev-parse ${hook_com[branch]}@{upstream} >/dev/null 2>&1 || return 0

  local -a ahead_and_behind=(
      $(git rev-list --left-right --count HEAD...${hook_com[branch]}@{upstream} 2>/dev/null)
  )

  ahead=${ahead_and_behind[1]}
  behind=${ahead_and_behind[2]}

  local ahead_symbol="%{$fg[red]%}⇡%{$reset_color%}${ahead}"
  local behind_symbol="%{$fg[cyan]%}⇣%{$reset_color%}${behind}"
  (( $ahead )) && gitstatus+=( "${ahead_symbol}" )
  (( $behind )) && gitstatus+=( "${behind_symbol}" )
  hook_com[misc]+=${(j:/:)gitstatus}
}

## git: Show remote branch name for remote-tracking branches
function +vi-git-remotebranch() {
    local remote

    # Are we on a remote-tracking branch?
    remote=${$(git rev-parse --verify ${hook_com[branch]}@{upstream} \
        --symbolic-full-name 2>/dev/null)/refs\/remotes\/}

    # The first test will show a tracking branch whenever there is one. The
    # second test, however, will only show the remote branch's name if it
    # differs from the local one.
    # if [[ -n ${remote} ]] ; then
    if [[ -n ${remote} && ${remote#*/} != ${hook_com[branch]} ]] ; then
        hook_com[branch]="${hook_com[branch]}→[${remote}]"
    fi
}

function __prompt_precmd() {
  vcs_info
}

function __python_venv() {
    [ $VIRTUAL_ENV ] && echo ' ('`basename $VIRTUAL_ENV`')'
}

PROMPT='$prompt_newline%F{131}∷ 20%D %* ∷$prompt_newline%F{108}${PWD/#$HOME/~}%F{131}$(__python_venv)%F{108} 〉%f'

function __set_rprompt() {
  RPROMPT="${_git_status_prompt:-$placeholder}%F{101}[%m]%f"
}

autoload -U add-zsh-hook
add-zsh-hook precmd __prompt_precmd
add-zsh-hook precmd __set_rprompt
add-zsh-hook precmd __async_vcs_start
add-zsh-hook chpwd () {
    _git_status_prompt=""
}

# source: https://github.com/akinsho/dotfiles/blob/main/.config/zsh/.zshrc
# Async prompt in Zsh
# Rather than using zpty (a pseudo terminal) under the hood
# as is the case with zsh-async this method forks a process sends
# it the command to evaluate which is written to a file descriptor
#
# terminology:
# exec - replaces the current shell. This means no subshell is
# created and the current process is replaced with this new command.
# fd/FD - file descriptor
# &- closes a FD e.g. "exec 3<&-" closes FD 3
# file descriptor 0 is stdin (the standard input),
# 1 is stdout (the standard output),
# 2 is stderr (the standard error).
#
# https://www.zsh.org/mla/users/2018/msg00424.html
# https://github.com/sorin-ionescu/prezto/pull/1805/files#diff-6a24e7644c4c0969110e86872283ec82L79
# https://github.com/zsh-users/zsh-autosuggestions/pull/338/files
__async_vcs_start() {
  # Close the last file descriptor to invalidate old requests
  if [[ -n "$__prompt_async_fd" ]] && { true <&$__prompt_async_fd } 2>/dev/null; then
    exec {__prompt_async_fd}<&-
    zle -F $__prompt_async_fd
  fi
  # fork a process to fetch the vcs status and open a pipe to read from it
  exec {__prompt_async_fd}< <(
    __async_vcs_info $PWD
  )

  # When the fd is readable, call the response handler
  zle -F "$__prompt_async_fd" __async_vcs_info_done
}

__async_vcs_info() {
  cd -q "$1"
  vcs_info
  print ${vcs_info_msg_0_}
}

# Called when new data is ready to be read from the pipe
__async_vcs_info_done() {
  # Read everything from the fd
  _git_status_prompt="$(<&$1)"
  # check if vcs info is returned, if not set the prompt
  # to a non visible character to clear the placeholder
  # NOTE: -z returns true if a string value has a length of 0
  if [[ -z $_git_status_prompt ]]; then
    _git_status_prompt=" "
  fi
  # remove the handler and close the file descriptor
  zle -F "$1"
  exec {1}<&-
  zle && zle reset-prompt
}
